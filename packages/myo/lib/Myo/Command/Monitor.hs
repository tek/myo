module Myo.Command.Monitor where

-- import Conduit (mapC, mapMC, runConduit, sinkNull, (.|))
-- import Control.Concurrent.Lifted (fork)
-- import Control.Exception (IOException)
-- import Control.Exception.Lifted (try)
-- import qualified Data.ByteString as ByteString (concat)
-- import qualified Data.ByteString.Lazy as LB (ByteString, toChunks)
-- import qualified Data.ByteString.Search as ByteString (replace)
-- import Data.Conduit.List (unfoldM)
-- import Data.Conduit.Network.Unix (sourceSocket)
-- import Data.Conduit.TMChan (TMChan, newTMChan, sinkTMChan, sourceTMChan)
-- import Data.Hourglass (Elapsed (Elapsed), Seconds (Seconds))
-- import Network.Socket (Socket)
-- import Path (Abs, File, Path, toFilePath)
-- import Prelude hiding (state)
-- import Ribosome (ErrorMessage (ErrorMessage))
-- import Ribosome.Config.Setting (setting)
-- import Ribosome.Control.Exception (catchAny, tryAny)
-- import Ribosome.Data.SettingError (SettingError)
-- import Ribosome.Error.Report (processErrorReport')
-- import Ribosome.Log (showDebug)
-- import System.Hourglass (timeCurrent)

-- import Myo.Command.Data.CommandState (CommandState)
-- import qualified Myo.Command.Data.CommandState as CommandState (executing, monitorChan)
-- import Myo.Command.Data.Execution (Execution (Execution), ExecutionMonitor (ExecutionMonitor), ExecutionState (..))
-- import Myo.Command.Data.MonitorEvent (MonitorEvent (CommandOutput, Tick))
-- import Process (Pid)
-- import Myo.Command.Execution (killExecution, modifyExecutionState, setExecutionState, storeOutputSocket)
-- import Myo.Command.Log (appendLog)
-- import Myo.Network.Socket (socketBind)
-- import qualified Myo.Settings as Settings (processTimeout)
-- import Myo.System.Proc (processExists)

-- strictByteString :: LB.ByteString -> ByteString
-- strictByteString =
--   ByteString.concat . LB.toChunks

-- replace :: Text -> Text -> ByteString -> ByteString
-- replace from to =
--   strictByteString . ByteString.replace (encodeUtf8 from :: ByteString) (encodeUtf8 to :: ByteString)

-- sanitizeOutput :: ByteString -> ByteString
-- sanitizeOutput =
--   replace "\r\n" "\n"

-- checkTracked ::
--   Member (AtomicState Env) r =>
--   Ident ->
--   Pid ->
--   m ()
-- checkTracked ident pid = do
--   exists <- processExists pid
--   unless exists kill
--   where
--     kill = do
--       Log.debug $ "tracked command `" <> identText ident <> "` has no process anymore"
--       void . tryAny $ killExecution ident

-- promoteExecution ::
--   Member (AtomicState Env) r =>
--   Ident ->
--   m ()
-- promoteExecution ident =
--   modifyExecutionState ident trans
--   where
--     trans Pending = do
--       Log.debug $ "pid detection for `" <> identText ident <> "` timed out"
--       pure Unknown
--     trans (Starting pid) = do
--       Log.debug $ "promoting tracked command `" <> identText ident <> "` with " <> show pid
--       pure $ Tracked pid
--     trans a =
--       pure a

-- promoteTimedOutExecution ::
--   Member (AtomicState Env) r =>
--   Ident ->
--   Elapsed ->
--   ExecutionState ->
--   m ()
-- promoteTimedOutExecution ident started =
--   checkState
--   where
--     checkState Pending =
--       check
--     checkState (Starting _) =
--       check
--     checkState _ =
--       pure ()
--     check = do
--       now <- liftIO timeCurrent
--       timeout <- setting Settings.processTimeout
--       when (timedOut now timeout) (promoteExecution ident)
--     timedOut now timeout =
--       now - started > Elapsed (Seconds (fromIntegral timeout))

-- checkExecuting ::
--   Member (AtomicState Env) r =>
--   Execution ->
--   m ()
-- checkExecuting (Execution ident _ _ (ExecutionMonitor state started _ checkPending)) = do
--   catchAny (showDebug "checking execution:") $ check state
--   promoteTimedOutExecution ident started state
--   where
--     check Pending =
--       update =<< query
--     check (Starting _) =
--       updateStarting =<< query
--     check (Tracked pid) =
--       checkTracked ident pid
--     check _ =
--       pure ()
--     query =
--       liftIO checkPending
--     updateStarting s@(Starting _) =
--       update s
--     updateStarting _ =
--       pure ()
--     update =
--       setExecutionState ident

-- handleEvent ::
--   Member (AtomicState Env) r =>
--   MonitorEvent ->
--   m ()
-- handleEvent (CommandOutput ident bytes) =
--   Log.debug @Text ("command output: " <> decodeUtf8 (sanitizeOutput bytes)) *>
--   appendLog ident (sanitizeOutput bytes)
-- handleEvent Tick =
--   traverse_ checkExecuting =<< atomicGets CommandState.executing

-- listenerErrorReport :: Socket -> IOException -> ErrorMessage
-- listenerErrorReport sock ex =
--   ErrorMessage "command monitor failed" ["exception in output listener:", show ex, "socket: " <> show sock] Debug

-- listener ::
--   Nvim m =>
--   Ident ->
--   Socket ->
--   TMChan MonitorEvent ->
--   m ()
-- listener cmdIdent sock listenChan = do
--   result <- try $ runConduit $ sourceSocket sock .| mapC (CommandOutput cmdIdent) .| sinkTMChan listenChan
--   whenLeft () result (processErrorReport' "monitor" . listenerErrorReport sock)

-- listen ::
--   Nvim m =>
--   Member (AtomicState Env) r =>
--   Ident ->
--   Path Abs File ->
--   TMChan MonitorEvent ->
--   m ()
-- listen cmdIdent logPath listenChan =
--   either failure success =<< tryAny (socketBind logPath)
--   where
--     success sock = do
--       Log.debug $ "listening on socket at " <> toFilePath logPath
--       storeOutputSocket sock cmdIdent
--       void $ forkListener sock
--     failure err =
--       Log.debug $ "could not bind command output socket for `" <> identText cmdIdent <> "`: " <> show err
--     forkListener sock =
--       fork $ listener cmdIdent sock listenChan

-- runMonitor ::
--   Member (AtomicState Env) r =>
--   TMChan MonitorEvent ->
--   m ()
-- runMonitor listenChan =
--   runConduit $ sourceTMChan listenChan .| mapMC handleEvent .| sinkNull

-- runClock ::
--   TMChan MonitorEvent ->
--   m ()
-- runClock listenChan =
--   runConduit $ unfoldM unfolder () .| sinkTMChan listenChan
--   where
--     unfolder _ =
--       sleep 0.1 $> Just (Tick, ())

-- startMonitor ::
--   Member (AtomicState Env) r =>
--   m (TMChan MonitorEvent)
-- startMonitor = do
--   chan <- atomically newTMChan
--   void $ fork $ runMonitor chan
--   void $ fork $ runClock chan
--   setL @CommandState CommandState.monitorChan (Just chan)
--   pure chan

-- ensureMonitor ::
--   Member (AtomicState Env) r =>
--   m (TMChan MonitorEvent)
-- ensureMonitor = do
--   current <- atomicGets CommandState.monitorChan
--   maybe startMonitor pure current

-- monitorCommand ::
--   Member (AtomicState Env) r =>
--   Ident ->
--   Path Abs File ->
--   m ()
-- monitorCommand cmdIdent logPath =
--   listen cmdIdent logPath =<< ensureMonitor
